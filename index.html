<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Road Racer</title>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="format-detection" content="telephone=no" />

  <script src="assets/phaser.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      height: 100%;
      width: 100%;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      margin: 0 auto;
      touch-action: none;
    }

    #ios-permission-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.75);
      z-index: 9999;
    }
    #ios-permission-overlay button {
      font-family: Arial, sans-serif;
      font-weight: 800;
      font-size: 18px;
      padding: 14px 18px;
      border-radius: 14px;
      border: 0;
    }
  </style>
</head>
<body>

<div id="ios-permission-overlay">
  <button id="ios-permission-btn">Tap to enable tilt</button>
</div>

<script>
const W = 360;
const H = 640;

const ROAD_LEFT = 50;
const ROAD_RIGHT = 310;
const LANE_COUNT = 5;

const BASE_ROAD_SPEED = 500;
const ENEMY_ROAD_GAP = 70;

const HITBOX_W = 0.7;
const HITBOX_H = 0.8;

const MIN_SPAWN_GAP_Y = 210;

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  physics: { default: "arcade", arcade: { gravity: { y: 0 }, debug: false } },
  scene: { preload, create, update }
};

new Phaser.Game(config);

let car, enemies, lanes;
let score = 0, scoreText;
let playing = false;
let gameOver = false;

let road1, road2, roadScale = 1;
let roadScrollSpeed = 0;
let enemySpeed = 0;

let nextSpawnAt = 0;
let difficulty = 0;
let lastDifficultyBumpScore = 0;
let lastSpawnLaneIndex = -1;

const ENEMY_KEYS = ["enemy_black","enemy_blue","enemy_orange","enemy_green"];

let rawGamma = 0;
let gammaZero = 0;
let gammaFiltered = 0;

let neutralDeadzone = 4;
let steerSensitivity = 0.9;
let steerMaxSpeed = 300;
let steerSmooth = 0.08;
let maxGammaAbs = 25;

let minX, maxX;
let overlayUI = {};

let collisionTriggered = false;

// ---------------- Explosion (STATIC) ----------------

function spawnExplosion(scene, x, y) {
  const boom = scene.add.image(x, y, "explosion").setOrigin(0.5);
  boom.setDepth(9999);

  const targetW = 90;
  boom.setScale(targetW / (boom.width || 1));
}

// ---------------- Phaser ----------------

function preload() {
  this.load.image("car", "assets/car.png");
  this.load.image("road", "assets/road.png");

  this.load.image("enemy_black", "assets/blackcar.png");
  this.load.image("enemy_blue", "assets/bluecar.png");
  this.load.image("enemy_orange", "assets/orangecar.png");
  this.load.image("enemy_green", "assets/greencar.png");

  this.load.image("ui_start", "assets/ui_start.png");
  this.load.image("ui_logo", "assets/ui_logo.png");
  this.load.image("ui_gameover", "assets/gameover.png");
  this.load.image("ui_restart", "assets/restart.png");

  this.load.image("explosion", "assets/explosion.png");
}

function create() {
  lanes = [];
  const roadWidth = ROAD_RIGHT - ROAD_LEFT;
  const laneSpacing = roadWidth / (LANE_COUNT - 1);
  for (let i = 0; i < LANE_COUNT; i++) lanes.push(ROAD_LEFT + i * laneSpacing);

  minX = ROAD_LEFT;
  maxX = ROAD_RIGHT;

  road1 = this.add.image(W/2, H/2, "road");
  roadScale = Math.max(W / road1.width, H / road1.height);
  road1.setScale(roadScale);

  road2 = this.add.image(W/2, H/2 - road1.height * roadScale, "road");
  road2.setScale(roadScale);

  car = this.physics.add.sprite(lanes[2], H - 90, "car");
  scaleSpriteToWidth(car, 46);
  car.body.setSize(car.width * HITBOX_W, car.height * HITBOX_H, true);

  enemies = this.physics.add.group();

  scoreText = this.add.text(10, 10, "Score: 0", {
    fontSize: "18px",
    fontStyle: "bold",
    color: "#fff"
  }).setStroke("#000", 5);

  this.physics.add.overlap(car, enemies, (player, enemy) => {
    if (collisionTriggered || gameOver) return;
    collisionTriggered = true;

    spawnExplosion(this, (player.x + enemy.x) / 2, (player.y + enemy.y) / 2);
    onGameOver.call(this);
  });

  setupTiltControls();
  showStartOverlay.call(this);
}

function update(time, delta) {
  let dt = Math.min(delta / 1000, 0.12);

  if (playing && !gameOver) {
    scrollRoad(dt);
    spawnLogic(time);
    smoothSteer(dt);

    enemies.children.iterate(e => e && (e.y += e.speed * dt));
  }
}

// ---------------- Logic ----------------

function smoothSteer(dt) {
  let g = Phaser.Math.Clamp(rawGamma - gammaZero, -maxGammaAbs, maxGammaAbs);
  gammaFiltered = lerp(gammaFiltered, g, steerSmooth);

  let gf = Math.abs(gammaFiltered) < neutralDeadzone ? 0 : gammaFiltered;
  car.x = Phaser.Math.Clamp(
    car.x + (gf / maxGammaAbs) * steerSensitivity * steerMaxSpeed * dt,
    minX, maxX
  );
}

function scrollRoad(dt) {
  road1.y += roadScrollSpeed * dt;
  road2.y += roadScrollSpeed * dt;

  const h = road1.height * roadScale;
  if (road1.y - H/2 >= h) road1.y = road2.y - h;
  if (road2.y - H/2 >= h) road2.y = road1.y - h;
}

function spawnLogic(timeMs) {
  if (timeMs < nextSpawnAt) return;

  const dist = Phaser.Math.Between(600, 900);
  nextSpawnAt = timeMs + (dist / enemySpeed) * 1000;

  const idx = Phaser.Math.Between(0, LANE_COUNT - 1);
  const e = enemies.create(lanes[idx], -120, Phaser.Utils.Array.GetRandom(ENEMY_KEYS));
  scaleSpriteToWidth(e, 46);
  e.body.setSize(e.width * HITBOX_W, e.height * HITBOX_H, true);
  e.speed = enemySpeed;
}

function startGame() {
  score = 0;
  collisionTriggered = false;

  playing = true;
  gameOver = false;

  roadScrollSpeed = BASE_ROAD_SPEED;
  enemySpeed = roadScrollSpeed + ENEMY_ROAD_GAP;

  enemies.clear(true, true);
  hideOverlay();

  gammaZero = rawGamma;
}

function onGameOver() {
  gameOver = true;
  playing = false;
  roadScrollSpeed = 0;
  this.physics.pause();
  showGameOverOverlay.call(this);
}

// ---------------- UI ----------------

function showStartOverlay() {
  overlayUI.btn = this.add.image(W/2, H/2 + 50, "ui_start")
    .setInteractive()
    .on("pointerdown", () => startGame.call(this));
}

function showGameOverOverlay() {
  overlayUI.btn = this.add.image(W/2, H/2 + 55, "ui_restart")
    .setInteractive()
    .on("pointerdown", () => startGame.call(this));
}

function hideOverlay() {
  Object.values(overlayUI).forEach(o => o.destroy && o.destroy());
  overlayUI = {};
}

// ---------------- Tilt ----------------

function setupTiltControls() {
  window.addEventListener("deviceorientation", e => {
    if (e && typeof e.gamma === "number") rawGamma = e.gamma;
  });
}

// ---------------- Helpers ----------------

function scaleSpriteToWidth(s, w) { s.setScale(w / s.width); }
function lerp(a, b, t) { return a + (b - a) * t; }
</script>

</body>
</html>
