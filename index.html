<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Road Racer</title>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;          /* prevent page scroll */
      height: 100%;
      width: 100%;
      touch-action: none;        /* prevent gestures affecting frame pacing */
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      margin: 0 auto;
      touch-action: none;        /* important on Android WebView */
    }
  </style>
</head>
<body>

<script>
const W = 360;
const H = 640;

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  physics: { default: "arcade", arcade: { gravity: { y: 0 }, debug: false } },
  scene: { preload, create, update }
};

new Phaser.Game(config);

let car, enemies, lanes;
let score = 0, scoreText;
let playing = false;
let gameOver = false;

let road1, road2;
let roadScale = 1;

// ✅ TIME-BASED SPEEDS (pixels per second)
let roadScrollSpeed = 0;     // px/sec
let enemySpeed = 0;          // px/sec

// spawn + difficulty
let nextSpawnAt = 0;
let difficulty = 0;
let lastDifficultyBumpScore = 0;
let lastSpawnLaneIndex = -1;

// enemy skins
const ENEMY_KEYS = ["enemy_black", "enemy_blue", "enemy_orange", "enemy_green"];

// ✅ Smooth tilt steering (calibration + anti-teleport), no auto-centering
let rawGamma = 0;
let gammaZero = 0;
let gammaFiltered = 0;

let neutralDeadzone = 4;
let steerSensitivity = 0.9;
let steerMaxSpeed = 260;   // px/sec
let steerSmooth = 0.08;
let maxGammaAbs = 25;

// road bounds
let minX = 70;
let maxX = 280;

let overlayUI = {};

function preload() {
  this.load.image("car", "assets/car.png");
  this.load.image("road", "assets/road.png");

  this.load.image("enemy_black", "assets/blackcar.png");
  this.load.image("enemy_blue", "assets/bluecar.png");
  this.load.image("enemy_orange", "assets/orangecar.png");
  this.load.image("enemy_green", "assets/greencar.png");
}

function create() {
  lanes = [70, 180, 280];
  minX = lanes[0];
  maxX = lanes[2];

  // road fill loop
  road1 = this.add.image(W/2, H/2, "road");
  roadScale = Math.max(W / road1.width, H / road1.height);
  road1.setScale(roadScale);

  road2 = this.add.image(W/2, H/2 - (road1.height * roadScale), "road");
  road2.setScale(roadScale);

  car = this.physics.add.sprite(lanes[1], H - 90, "car");
  car.setCollideWorldBounds(false);
  scaleSpriteToWidth(car, 47);

  enemies = this.physics.add.group();

  scoreText = this.add.text(10, 10, "Score: 0", {
    fontSize: "18px",
    fill: "#ffffff"
  });

  this.physics.add.overlap(car, enemies, () => onGameOver.call(this), null, this);

  // ✅ block touch from doing browser-like behavior
  this.input.mouse?.disableContextMenu?.();
  this.input.addPointer(1);

  setupTiltControls();
  showStartOverlay.call(this);

  // keyboard fallback (desktop)
  this.input.keyboard.on("keydown-LEFT", () => { rawGamma = -18; });
  this.input.keyboard.on("keydown-RIGHT", () => { rawGamma = 18; });
  this.input.keyboard.on("keyup-LEFT", () => { rawGamma = 0; });
  this.input.keyboard.on("keyup-RIGHT", () => { rawGamma = 0; });
}

function update(time, delta) {
  // ✅ stable dt clamp
  const dt = Math.min(delta / 1000, 0.05);

  if (playing && !gameOver) {
    scrollRoad(dt);
    maybeIncreaseDifficulty();
    spawnLogic(time);
    smoothSteer(dt);
  }

  if (!playing || gameOver) return;

  // ✅ score when enemies exit screen
  enemies.children.iterate((e) => {
    if (e && e.y > H + 140) {
      e.destroy();
      score++;
      scoreText.setText("Score: " + score);
    }
  });
}

// -------------------- SMOOTH STEERING (no auto-center) --------------------

function smoothSteer(dt) {
  let g = rawGamma - gammaZero;
  g = Phaser.Math.Clamp(g, -maxGammaAbs, maxGammaAbs);

  gammaFiltered = lerp(gammaFiltered, g, steerSmooth);

  let gf = gammaFiltered;
  if (Math.abs(gf) < neutralDeadzone) gf = 0;

  const norm = Phaser.Math.Clamp(gf / maxGammaAbs, -1, 1) * steerSensitivity;
  const vx = norm * steerMaxSpeed;

  car.x += vx * dt;
  car.x = Phaser.Math.Clamp(car.x, minX, maxX);
}

// -------------------- ROAD LOOP (TIME-BASED) --------------------

function scrollRoad(dt) {
  const speed = roadScrollSpeed * dt;

  road1.y += speed;
  road2.y += speed;

  const roadHeight = road1.height * roadScale;

  if (road1.y - H/2 >= roadHeight) road1.y = road2.y - roadHeight;
  if (road2.y - H/2 >= roadHeight) road2.y = road1.y - roadHeight;
}

// -------------------- DIFFICULTY --------------------

function maybeIncreaseDifficulty() {
  if (score - lastDifficultyBumpScore >= 6) {
    lastDifficultyBumpScore = score;
    difficulty++;

    // ✅ px/sec bumps
    roadScrollSpeed += 25;
    enemySpeed += 90;

    steerMaxSpeed = Math.min(360, steerMaxSpeed + 8);
  }
}

// -------------------- SPAWNING --------------------

function spawnLogic(timeMs) {
  if (timeMs < nextSpawnAt) return;

// --- SPACING: far at start, tighter with difficulty (distance-based) ---
const minDist = Math.max(680 - difficulty * 55, 240); // px
const maxDist = Math.max(980 - difficulty * 80, 320); // px
const dist = Phaser.Math.Between(minDist, maxDist);

const delay = (dist / enemySpeed) * 1000;
nextSpawnAt = timeMs + Math.max(210, delay);

// spawn one
const laneA = pickLaneIndexAvoidRepeat();
spawnEnemyInLane(laneA);

// --- DOUBLES: ramps up with difficulty ---
const allowDouble = difficulty >= 1;
if (allowDouble) {
  const doubleChance = Math.min(0.12 + difficulty * 0.06, 0.55); // up to 55%
  if (Math.random() < doubleChance) {
    const laneB = pickDifferentLaneIndex(laneA);

    // make late-game doubles feel "almost simultaneous"
    const extraDelayMin = Math.max(80, 180 - difficulty * 10);
    const extraDelayMax = Math.max(120, 260 - difficulty * 12);
    const extraDelay = Phaser.Math.Between(extraDelayMin, extraDelayMax);

    setTimeout(() => {
      if (playing && !gameOver) spawnEnemyInLane(laneB);
    }, extraDelay);
  }
}



  const laneA = pickLaneIndexAvoidRepeat();
  spawnEnemyInLane(laneA);

  const allowDouble = difficulty >= 1;
  if (allowDouble) {
    const doubleChance = Math.min(0.12 + difficulty * 0.05, 0.50);
    if (Math.random() < doubleChance) {
      const laneB = pickDifferentLaneIndex(laneA);
      const extraDelay = Phaser.Math.Between(120, 260);
      setTimeout(() => {
        if (playing && !gameOver) spawnEnemyInLane(laneB);
      }, extraDelay);
    }
  }
}

function pickLaneIndexAvoidRepeat() {
  let choices = [0, 1, 2];
  if (lastSpawnLaneIndex !== -1 && Math.random() < 0.75) {
    choices = choices.filter(i => i !== lastSpawnLaneIndex);
  }
  const picked = Phaser.Utils.Array.GetRandom(choices);
  lastSpawnLaneIndex = picked;
  return picked;
}

function pickDifferentLaneIndex(notThisIndex) {
  let options = [0, 1, 2].filter(i => i !== notThisIndex);
  if (lastSpawnLaneIndex !== -1 && Math.random() < 0.6) {
    const options2 = options.filter(i => i !== lastSpawnLaneIndex);
    if (options2.length > 0) options = options2;
  }
  const picked = Phaser.Utils.Array.GetRandom(options);
  lastSpawnLaneIndex = picked;
  return picked;
}

function spawnEnemyInLane(laneIndex) {
  if (!playing || gameOver) return;

  const enemyKey = Phaser.Utils.Array.GetRandom(ENEMY_KEYS);
  const laneX = lanes[laneIndex];

  const e = enemies.create(laneX, -120, enemyKey);
  scaleSpriteToWidth(e, 47);

  // ✅ px/sec (Arcade uses px/sec already)
  e.setVelocityY(enemySpeed);

  e.x += Phaser.Math.Between(-2, 2);
}

// -------------------- GAME FLOW --------------------

function startGame() {
  score = 0;
  scoreText.setText("Score: 0");
  gameOver = false;
  playing = true;

  difficulty = 0;
  lastDifficultyBumpScore = 0;
  lastSpawnLaneIndex = -1;

  // ✅ set base speeds in px/sec
  enemySpeed = 520;
  roadScrollSpeed = 180;

  enemies.clear(true, true);
  hideOverlay();

  // calibrate center on START
  gammaZero = rawGamma;
  gammaFiltered = 0;

  nextSpawnAt = performance.now() + 850;
}

function onGameOver() {
  if (gameOver) return;

  gameOver = true;
  playing = false;
  roadScrollSpeed = 0;

  this.physics.pause();
  showGameOverOverlay.call(this);
}

// -------------------- UI --------------------

function showStartOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.45);

  overlayUI.title = this.add.text(W/2, H/2 - 90, "ROAD RACER", {
    fontSize: "32px",
    fill: "#ffffff"
  }).setOrigin(0.5);

  overlayUI.tip = this.add.text(W/2, H/2 - 40, "Hold phone normally, then tap START", {
    fontSize: "14px",
    fill: "#dddddd"
  }).setOrigin(0.5);

  overlayUI.btn = makeButton(this, W/2, H/2 + 40, "START", () => {
    this.physics.resume();
    startGame.call(this);
  });
}

function showGameOverOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0x000000, 0.45);

  overlayUI.title = this.add.text(W/2, H/2 - 90, "GAME OVER", {
    fontSize: "32px",
    fill: "#ff4444"
  }).setOrigin(0.5);

  overlayUI.tip = this.add.text(W/2, H/2 - 40, `Final Score: ${score}`, {
    fontSize: "16px",
    fill: "#ffffff"
  }).setOrigin(0.5);

  overlayUI.btn = makeButton(this, W/2, H/2 + 40, "RESTART", () => {
    this.physics.resume();
    startGame.call(this);
  });
}

function hideOverlay() {
  Object.values(overlayUI).forEach(o => o && o.destroy && o.destroy());
  overlayUI = {};
}

function makeButton(scene, x, y, label, onClick) {
  const btnBg = scene.add.rectangle(x, y, 170, 54, 0x22c55e, 1)
    .setStrokeStyle(2, 0xffffff, 1);

  const btnText = scene.add.text(x, y, label, {
    fontSize: "20px",
    fill: "#ffffff"
  }).setOrigin(0.5);

  btnBg.setInteractive({ useHandCursor: true });
  btnBg.on("pointerdown", (p) => {
    // prevent any default interaction weirdness
    if (p && p.event && p.event.preventDefault) p.event.preventDefault();
    onClick();
  });

  return { destroy: () => { btnBg.destroy(); btnText.destroy(); } };
}

// -------------------- TILT --------------------

function setupTiltControls() {
  const requestIOSPermissionIfNeeded = async () => {
    try {
      if (
        typeof DeviceOrientationEvent !== "undefined" &&
        typeof DeviceOrientationEvent.requestPermission === "function"
      ) {
        const result = await DeviceOrientationEvent.requestPermission();
        console.log("iOS tilt permission:", result);
      }
    } catch (e) {
      console.log("Tilt permission error:", e);
    }
  };

  // iOS requires a user gesture. Android ignores this.
  window.addEventListener("click", () => requestIOSPermissionIfNeeded(), { once: true });

  // ✅ keep reading gamma while game is running (fine)
  window.addEventListener("deviceorientation", (event) => {
    if (!playing || gameOver) return;
    rawGamma = event.gamma ?? 0;
  }, { passive: true });
}

// -------------------- HELPERS --------------------

function scaleSpriteToWidth(sprite, targetWidthPx) {
  const texW = sprite.width || 1;
  sprite.setScale(targetWidthPx / texW);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}
</script>

</body>
</html>
