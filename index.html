
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Road Racer</title>

  <script src="assets/phaser.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      height: 100%;
      width: 100%;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      margin: 0 auto;
      touch-action: none;
    }
  </style>
</head>
<body>

<script>
const W = 360;
const H = 640;

// 5 lanes across the road area
const ROAD_LEFT = 50;
const ROAD_RIGHT = 310;
const LANE_COUNT = 5;

// pacing
const BASE_ROAD_SPEED = 500;   // px/sec
const ENEMY_ROAD_GAP = 70;     // enemy slightly faster than road

// collision tuning (touch = bang)
const HITBOX_W = 0.7;         // wider hitbox = easier crash
const HITBOX_H = 0.8;

// ‚úÖ anti-unfair-spawns tuning
const MIN_SPAWN_GAP_Y = 210;  // bigger = fewer ‚Äúwalls‚Äù (try 190‚Äì240)

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  physics: { default: "arcade", arcade: { gravity: { y: 0 }, debug: false } },
  scene: { preload, create, update }
};

new Phaser.Game(config);

let car, enemies, lanes;
let score = 0, scoreText;
let playing = false;
let gameOver = false;

let road1, road2;
let roadScale = 1;

let roadScrollSpeed = 0;
let enemySpeed = 0;

let nextSpawnAt = 0;
let difficulty = 0;
let lastDifficultyBumpScore = 0;
let lastSpawnLaneIndex = -1;

const ENEMY_KEYS = ["enemy_black", "enemy_blue", "enemy_orange", "enemy_green"];

// tilt steering (+ keyboard sim)
let rawGamma = 0;
let gammaZero = 0;
let gammaFiltered = 0;

let neutralDeadzone = 4;
let steerSensitivity = 0.9;
let steerMaxSpeed = 300;   // px/sec
let steerSmooth = 0.08;
let maxGammaAbs = 25;

let minX, maxX;
let overlayUI = {};

// üîä score sound
let scoreSound;

function preload() {
  this.load.image("car", "assets/car.png");
  this.load.image("road", "assets/road.png");

  this.load.image("enemy_black", "assets/blackcar.png");
  this.load.image("enemy_blue", "assets/bluecar.png");
  this.load.image("enemy_orange", "assets/orangecar.png");
  this.load.image("enemy_green", "assets/greencar.png");

  // UI images
  this.load.image("ui_start", "assets/ui_start.png");
  this.load.image("ui_logo", "assets/ui_logo.png");
  this.load.image("ui_gameover", "assets/gameover.png");
  this.load.image("ui_restart", "assets/restart.png");

  // üîä score +1 sound
  this.load.audio("scoreSound", "assets/score.mp3");
}

function create() {
  // build 5 evenly spaced lanes
  lanes = [];
  const roadWidth = ROAD_RIGHT - ROAD_LEFT;
  const laneSpacing = roadWidth / (LANE_COUNT - 1);
  for (let i = 0; i < LANE_COUNT; i++) {
    lanes.push(ROAD_LEFT + i * laneSpacing);
  }

  minX = ROAD_LEFT;
  maxX = ROAD_RIGHT;

  // road visuals
  road1 = this.add.image(W/2, H/2, "road");
  roadScale = Math.max(W / road1.width, H / road1.height);
  road1.setScale(roadScale);

  road2 = this.add.image(W/2, H/2 - (road1.height * roadScale), "road");
  road2.setScale(roadScale);

  // player
  car = this.physics.add.sprite(lanes[Math.floor(LANE_COUNT / 2)], H - 90, "car");
  scaleSpriteToWidth(car, 46);

  // ‚úÖ touch = bang: make hitbox almost the full sprite
  car.body.setSize(car.width * HITBOX_W, car.height * HITBOX_H, true);

  enemies = this.physics.add.group();

  scoreText = this.add.text(10, 10, "Score: 0", {
    fontFamily: "Arial, sans-serif",
    fontSize: "18px",
    fontStyle: "bold",
    color: "#ffffff"
  });
  scoreText.setStroke("#000000", 5);
  scoreText.setShadow(2, 2, "#000000", 8, true, true);

  // collision
  this.physics.add.overlap(car, enemies, () => onGameOver.call(this), null, this);

  // üîä create sound
  scoreSound = this.sound.add("scoreSound", { volume: 0.6 });

  setupTiltControls();
  showStartOverlay.call(this);

  // ‚úÖ keyboard fallback for browser testing (simulates tilt)
  this.input.keyboard.on("keydown-LEFT", () => { rawGamma = -18; });
  this.input.keyboard.on("keydown-RIGHT", () => { rawGamma = 18; });
  this.input.keyboard.on("keyup-LEFT", () => { rawGamma = 0; });
  this.input.keyboard.on("keyup-RIGHT", () => { rawGamma = 0; });
}

function update(time, delta) {
  // IMPORTANT: not too strict, prevents ‚Äútouch speeds it up‚Äù feeling
  let dt = delta / 1000;
  dt = Math.min(dt, 0.12);

  if (playing && !gameOver) {
    scrollRoad(dt);
    maybeIncreaseDifficulty();
    spawnLogic(time);
    smoothSteer(dt);

    // ‚úÖ SMOOTH enemy movement (dt-based)
    enemies.children.iterate(e => {
      if (!e) return;
      e.y += (e.speed || enemySpeed) * dt;
    });
  }

  // scoring when enemies pass bottom
  enemies.children.iterate(e => {
    if (e && e.y > H + 120) {
      e.destroy();
      score++;
      scoreText.setText("Score: " + score);
      if (scoreSound) scoreSound.play();
    }
  });
}

// ---------------- STEERING ----------------

function smoothSteer(dt) {
  let g = Phaser.Math.Clamp(rawGamma - gammaZero, -maxGammaAbs, maxGammaAbs);
  gammaFiltered = lerp(gammaFiltered, g, steerSmooth);

  let gf = Math.abs(gammaFiltered) < neutralDeadzone ? 0 : gammaFiltered;
  const vx = (gf / maxGammaAbs) * steerSensitivity * steerMaxSpeed;

  car.x += vx * dt;
  car.x = Phaser.Math.Clamp(car.x, minX, maxX);
}

// ---------------- ROAD ----------------

function scrollRoad(dt) {
  const s = roadScrollSpeed * dt;
  road1.y += s;
  road2.y += s;

  const h = road1.height * roadScale;
  if (road1.y - H/2 >= h) road1.y = road2.y - h;
  if (road2.y - H/2 >= h) road2.y = road1.y - h;
}

// ---------------- DIFFICULTY ----------------

function maybeIncreaseDifficulty() {
  if (score - lastDifficultyBumpScore >= 5) {
    lastDifficultyBumpScore = score;
    difficulty++;

    roadScrollSpeed += 15;
    enemySpeed = roadScrollSpeed + ENEMY_ROAD_GAP;

    steerMaxSpeed = Math.min(380, steerMaxSpeed + 8);
  }
}

// ---------------- SPAWNING (ANTI-UNFAIR WALLS) ----------------

// lane considered blocked if there is already an enemy near the top in that lane
function isLaneCurrentlyBlocked(laneIndex) {
  const x = lanes[laneIndex];
  let blocked = false;

  enemies.children.iterate(e => {
    if (!e) return;

    // same lane (allow tiny randomness wiggle)
    if (Math.abs(e.x - x) < 8) {
      // if enemy is still near top, don't spawn another here
      if (e.y < MIN_SPAWN_GAP_Y) blocked = true;
    }
  });

  return blocked;
}

// pick a safe lane; if none safe, fall back to any lane except avoidLane
function pickSafeLaneIndex(avoidLane = -1) {
  let candidates = [];
  for (let i = 0; i < LANE_COUNT; i++) {
    if (i === avoidLane) continue;
    if (!isLaneCurrentlyBlocked(i)) candidates.push(i);
  }

  // if everything blocked, allow any lane so game continues
  if (candidates.length === 0) {
    for (let i = 0; i < LANE_COUNT; i++) {
      if (i !== avoidLane) candidates.push(i);
    }
  }

  // avoid repeating last lane most of the time
  if (lastSpawnLaneIndex !== -1 && Math.random() < 0.7 && candidates.length > 1) {
    const filtered = candidates.filter(i => i !== lastSpawnLaneIndex);
    if (filtered.length > 0) candidates = filtered;
  }

  const pick = Phaser.Utils.Array.GetRandom(candidates);
  lastSpawnLaneIndex = pick;
  return pick;
}

function spawnLogic(timeMs) {
  if (timeMs < nextSpawnAt) return;

  // spacing in pixels between spawns (far early, closer later)
  const minDist = Math.max(780 - difficulty * 60, 280);
  const maxDist = Math.max(1150 - difficulty * 90, 360);
  const dist = Phaser.Math.Between(minDist, maxDist);

  const delay = (dist / enemySpeed) * 1000;
  nextSpawnAt = timeMs + Math.max(240, delay);

  // Spawn 1 enemy in a safe lane
  const laneA = pickSafeLaneIndex();
  spawnEnemyInLane(laneA);

  // doubles ramp up (but must still be fair)
  if (difficulty >= 2) {
    const doubleChance = Math.min(0.10 + difficulty * 0.05, 0.45);
    if (Math.random() < doubleChance) {
      const extraDelay = Phaser.Math.Between(120, 260);

      setTimeout(() => {
        if (!playing || gameOver) return;

        // pick a different safe lane for the second car
        const laneB = pickSafeLaneIndex(laneA);

        // if laneB somehow invalid, skip second spawn
        if (laneB !== -1) spawnEnemyInLane(laneB);
      }, extraDelay);
    }
  }
}

function spawnEnemyInLane(idx) {
  if (!playing || gameOver) return;

  const e = enemies.create(lanes[idx], -120, Phaser.Utils.Array.GetRandom(ENEMY_KEYS));
  scaleSpriteToWidth(e, 46);

  // ‚úÖ touch = bang hitbox
  e.body.setSize(e.width * HITBOX_W, e.height * HITBOX_H, true);

  // ‚úÖ store speed, move with dt in update()
  e.speed = enemySpeed;

  // tiny wiggle
  e.x += Phaser.Math.Between(-2, 2);
}

// ---------------- GAME FLOW ----------------

function startGame() {
  score = 0;
  difficulty = 0;
  lastDifficultyBumpScore = 0;
  lastSpawnLaneIndex = -1;

  playing = true;
  gameOver = false;

  roadScrollSpeed = BASE_ROAD_SPEED;
  enemySpeed = roadScrollSpeed + ENEMY_ROAD_GAP;

  enemies.clear(true, true);
  hideOverlay();

  gammaZero = rawGamma;
  gammaFiltered = 0;

  nextSpawnAt = performance.now() + 800;

  // ensure physics is running after restart
  this.physics.resume();
}

function onGameOver() {
  if (gameOver) return;

  gameOver = true;
  playing = false;
  roadScrollSpeed = 0;

  this.physics.pause();
  showGameOverOverlay.call(this);
}

// ---------------- UI ----------------

function showStartOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.45);

  overlayUI.logo = this.add.image(W/2, H/2 - 120, "ui_logo").setOrigin(0.5);
  scaleImageToWidth(overlayUI.logo, 260);

  overlayUI.tip = this.add.text(W/2, H/2 - 35, "Hold phone normally, then tap START", {
    fontFamily: "Arial, sans-serif",
    fontSize: "14px",
    fontStyle: "bold",
    color: "#ffffff"
  }).setOrigin(0.5);
  overlayUI.tip.setStroke("#000000", 5);
  overlayUI.tip.setShadow(2, 2, "#000000", 8, true, true);

  overlayUI.btn = this.add.image(W/2, H/2 + 50, "ui_start").setOrigin(0.5);
  scaleImageToWidth(overlayUI.btn, 220);
  overlayUI.btn.setInteractive({ useHandCursor: true }).on("pointerdown", () => {
    hideOverlay();
    startGame.call(this);
  });
}

function showGameOverOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.45);

  overlayUI.title = this.add.image(W/2, H/2 - 120, "ui_gameover").setOrigin(0.5);
  scaleImageToWidth(overlayUI.title, 200);

  overlayUI.tip = this.add.text(W/2, H/2 - 40, `Score: ${score}`, {
    fontFamily: "Arial, sans-serif",
    fontSize: "16px",
    fontStyle: "bold",
    color: "#ffffff"
  }).setOrigin(0.5);
  overlayUI.tip.setStroke("#000000", 5);
  overlayUI.tip.setShadow(2, 2, "#000000", 8, true, true);

  overlayUI.btn = this.add.image(W/2, H/2 + 55, "ui_restart").setOrigin(0.5);
  scaleImageToWidth(overlayUI.btn, 240);
  overlayUI.btn.setInteractive({ useHandCursor: true }).on("pointerdown", () => {
    hideOverlay();
    startGame.call(this);
  });
}

function hideOverlay() {
  Object.values(overlayUI).forEach(o => o && o.destroy && o.destroy());
  overlayUI = {};
}

// ---------------- TILT ----------------

function setupTiltControls() {
  window.addEventListener("deviceorientation", e => {
    if (!playing || gameOver) return;
    rawGamma = e.gamma ?? 0;
  }, { passive: true });
}

// ---------------- HELPERS ----------------

function scaleSpriteToWidth(s, w) {
  s.setScale(w / (s.width || 1));
}

function scaleImageToWidth(img, w) {
  img.setScale(w / (img.width || 1));
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}
</script>

</body>
</html>