<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Road Racer</title>

  <script src="assets/phaser.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      height: 100%;
      width: 100%;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      margin: 0 auto;
      touch-action: none;
    }
  </style>
</head>
<body>

<script>
const W = 360;
const H = 640;

// 5 lanes across the road area
const ROAD_LEFT = 50;
const ROAD_RIGHT = 310;
const LANE_COUNT = 5;

// pacing
const BASE_ROAD_SPEED = 360;   // px/sec
const ENEMY_ROAD_GAP = 70;     // enemy slightly faster than road

// collision tuning (touch = bang)
const HITBOX_W = 0.8;         // wider hitbox = easier crash
const HITBOX_H = 0.8;

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  physics: { default: "arcade", arcade: { gravity: { y: 0 }, debug: false } },
  scene: { preload, create, update }
};

new Phaser.Game(config);

let car, enemies, lanes;
let score = 0, scoreText;
let playing = false;
let gameOver = false;

let road1, road2;
let roadScale = 1;

let roadScrollSpeed = 0;
let enemySpeed = 0;

let nextSpawnAt = 0;
let difficulty = 0;
let lastDifficultyBumpScore = 0;
let lastSpawnLaneIndex = -1;

const ENEMY_KEYS = ["enemy_black", "enemy_blue", "enemy_orange", "enemy_green"];

// tilt steering (+ keyboard sim)
let rawGamma = 0;
let gammaZero = 0;
let gammaFiltered = 0;

let neutralDeadzone = 4;
let steerSensitivity = 0.9;
let steerMaxSpeed = 300;   // px/sec
let steerSmooth = 0.08;
let maxGammaAbs = 25;

let minX, maxX;
let overlayUI = {};

function preload() {
  this.load.image("car", "assets/car.png");
  this.load.image("road", "assets/road.png");

  this.load.image("enemy_black", "assets/blackcar.png");
  this.load.image("enemy_blue", "assets/bluecar.png");
  this.load.image("enemy_orange", "assets/orangecar.png");
  this.load.image("enemy_green", "assets/greencar.png");
}

function create() {
  // build 5 evenly spaced lanes
  lanes = [];
  const roadWidth = ROAD_RIGHT - ROAD_LEFT;
  const laneSpacing = roadWidth / (LANE_COUNT - 1);
  for (let i = 0; i < LANE_COUNT; i++) {
    lanes.push(ROAD_LEFT + i * laneSpacing);
  }

  minX = ROAD_LEFT;
  maxX = ROAD_RIGHT;

  // road visuals
  road1 = this.add.image(W/2, H/2, "road");
  roadScale = Math.max(W / road1.width, H / road1.height);
  road1.setScale(roadScale);

  road2 = this.add.image(W/2, H/2 - (road1.height * roadScale), "road");
  road2.setScale(roadScale);

  // player
  car = this.physics.add.sprite(lanes[Math.floor(LANE_COUNT / 2)], H - 90, "car");
  scaleSpriteToWidth(car, 46);

  // ✅ touch = bang: make hitbox almost the full sprite
  car.body.setSize(car.width * HITBOX_W, car.height * HITBOX_H, true);

  enemies = this.physics.add.group();

  scoreText = this.add.text(10, 10, "Score: 0", {
    fontSize: "18px",
    fill: "#fff"
  });

  // collision
  this.physics.add.overlap(car, enemies, () => onGameOver.call(this), null, this);

  setupTiltControls();
  showStartOverlay.call(this);

  // ✅ keyboard fallback for browser testing (simulates tilt)
  this.input.keyboard.on("keydown-LEFT", () => { rawGamma = -18; });
  this.input.keyboard.on("keydown-RIGHT", () => { rawGamma = 18; });
  this.input.keyboard.on("keyup-LEFT", () => { rawGamma = 0; });
  this.input.keyboard.on("keyup-RIGHT", () => { rawGamma = 0; });
}

function update(time, delta) {
  // IMPORTANT: not too strict, prevents “touch speeds it up” feeling
  let dt = delta / 1000;
  dt = Math.min(dt, 0.12);

  if (playing && !gameOver) {
    scrollRoad(dt);
    maybeIncreaseDifficulty();
    spawnLogic(time);
    smoothSteer(dt);
  }

  enemies.children.iterate(e => {
    if (e && e.y > H + 120) {
      e.destroy();
      score++;
      scoreText.setText("Score: " + score);
    }
  });
}

// ---------------- STEERING ----------------

function smoothSteer(dt) {
  let g = Phaser.Math.Clamp(rawGamma - gammaZero, -maxGammaAbs, maxGammaAbs);
  gammaFiltered = lerp(gammaFiltered, g, steerSmooth);

  let gf = Math.abs(gammaFiltered) < neutralDeadzone ? 0 : gammaFiltered;
  const vx = (gf / maxGammaAbs) * steerSensitivity * steerMaxSpeed;

  car.x += vx * dt;
  car.x = Phaser.Math.Clamp(car.x, minX, maxX);
}

// ---------------- ROAD ----------------

function scrollRoad(dt) {
  const s = roadScrollSpeed * dt;
  road1.y += s;
  road2.y += s;

  const h = road1.height * roadScale;
  if (road1.y - H/2 >= h) road1.y = road2.y - h;
  if (road2.y - H/2 >= h) road2.y = road1.y - h;
}

// ---------------- DIFFICULTY ----------------

function maybeIncreaseDifficulty() {
  if (score - lastDifficultyBumpScore >= 5) {
    lastDifficultyBumpScore = score;
    difficulty++;

    roadScrollSpeed += 15;
    enemySpeed = roadScrollSpeed + ENEMY_ROAD_GAP;

    steerMaxSpeed = Math.min(380, steerMaxSpeed + 8);
  }
}

// ---------------- SPAWNING ----------------

function spawnLogic(timeMs) {
  if (timeMs < nextSpawnAt) return;

  // spacing in pixels between spawns (far early, closer later)
  const minDist = Math.max(780 - difficulty * 60, 280);
  const maxDist = Math.max(1150 - difficulty * 90, 360);
  const dist = Phaser.Math.Between(minDist, maxDist);

  const delay = (dist / enemySpeed) * 1000;
  nextSpawnAt = timeMs + Math.max(240, delay);

  const laneA = pickLaneIndexAvoidRepeat();
  spawnEnemyInLane(laneA);

  // doubles ramp up (not too early)
  if (difficulty >= 2) {
    const doubleChance = Math.min(0.10 + difficulty * 0.05, 0.45);
    if (Math.random() < doubleChance) {
      const laneB = pickDifferentLaneIndex(laneA);
      const extraDelay = Phaser.Math.Between(120, 260);
      setTimeout(() => {
        if (playing && !gameOver) spawnEnemyInLane(laneB);
      }, extraDelay);
    }
  }
}

function pickLaneIndexAvoidRepeat() {
  let choices = [...Array(LANE_COUNT).keys()];
  if (lastSpawnLaneIndex !== -1 && Math.random() < 0.7) {
    choices = choices.filter(i => i !== lastSpawnLaneIndex);
  }
  const pick = Phaser.Utils.Array.GetRandom(choices);
  lastSpawnLaneIndex = pick;
  return pick;
}

function pickDifferentLaneIndex(notThis) {
  const opts = [...Array(LANE_COUNT).keys()].filter(i => i !== notThis);
  return Phaser.Utils.Array.GetRandom(opts);
}

function spawnEnemyInLane(idx) {
  if (!playing || gameOver) return;

  const e = enemies.create(lanes[idx], -120, Phaser.Utils.Array.GetRandom(ENEMY_KEYS));
  scaleSpriteToWidth(e, 46);

  // ✅ touch = bang hitbox
  e.body.setSize(e.width * HITBOX_W, e.height * HITBOX_H, true);

  e.setVelocityY(enemySpeed);
  e.x += Phaser.Math.Between(-2, 2);
}

// ---------------- GAME FLOW ----------------

function startGame() {
  score = 0;
  difficulty = 0;
  lastDifficultyBumpScore = 0;
  lastSpawnLaneIndex = -1;

  playing = true;
  gameOver = false;

  roadScrollSpeed = BASE_ROAD_SPEED;
  enemySpeed = roadScrollSpeed + ENEMY_ROAD_GAP;

  enemies.clear(true, true);
  hideOverlay();

  gammaZero = rawGamma;
  gammaFiltered = 0;

  nextSpawnAt = performance.now() + 800;

  // ensure physics is running after restart
  this.physics.resume();
}

function onGameOver() {
  if (gameOver) return;

  gameOver = true;
  playing = false;
  roadScrollSpeed = 0;

  this.physics.pause();
  showGameOverOverlay.call(this);
}

// ---------------- UI ----------------

function showStartOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.45);
  overlayUI.title = this.add.text(W/2, H/2 - 80, "ROAD RACER", { fontSize: "32px", fill: "#fff" }).setOrigin(0.5);
  overlayUI.tip = this.add.text(W/2, H/2 - 35, "Hold phone normally, then tap START", { fontSize: "14px", fill: "#ddd" }).setOrigin(0.5);

  overlayUI.btn = makeButton(this, W/2, H/2 + 40, "START", () => {
    hideOverlay();
    startGame.call(this);
  });
}

function showGameOverOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.45);
  overlayUI.title = this.add.text(W/2, H/2 - 80, "GAME OVER", { fontSize: "32px", fill: "#ff4444" }).setOrigin(0.5);
  overlayUI.tip = this.add.text(W/2, H/2 - 30, `Score: ${score}`, { fontSize: "16px", fill: "#fff" }).setOrigin(0.5);

  overlayUI.btn = makeButton(this, W/2, H/2 + 40, "RESTART", () => {
    hideOverlay();
    startGame.call(this);
  });
}

function hideOverlay() {
  Object.values(overlayUI).forEach(o => o && o.destroy && o.destroy());
  overlayUI = {};
}

function makeButton(scene, x, y, label, cb) {
  const bg = scene.add.rectangle(x, y, 170, 54, 0x22c55e).setStrokeStyle(2, 0xffffff, 1);
  const t = scene.add.text(x, y, label, { fontSize: "20px", fill: "#fff" }).setOrigin(0.5);
  bg.setInteractive({ useHandCursor: true }).on("pointerdown", cb);
  return { destroy: () => { bg.destroy(); t.destroy(); } };
}

// ---------------- TILT ----------------

function setupTiltControls() {
  window.addEventListener("deviceorientation", e => {
    if (!playing || gameOver) return;
    rawGamma = e.gamma ?? 0;
  }, { passive: true });
}

// ---------------- HELPERS ----------------

function scaleSpriteToWidth(s, w) {
  s.setScale(w / (s.width || 1));
}
function lerp(a, b, t) {
  return a + (b - a) * t;
}
</script>

</body>
</html>
