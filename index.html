<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Road Racer</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
  <style>
    body { margin: 0; background: #000; }
    canvas { display: block; margin: 0 auto; }
  </style>
</head>
<body>

<script>
const W = 360;
const H = 640;

const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  physics: { default: "arcade", arcade: { gravity: { y: 0 }, debug: false } },
  scene: { preload, create, update }
};

new Phaser.Game(config);

let car, enemies, lanes;
let score = 0, scoreText;
let playing = false;
let gameOver = false;

let road1, road2;
let roadScrollSpeed = 0;
let roadScale = 1;

let enemySpeed = 220;

// spawn + difficulty
let nextSpawnAt = 0;
let difficulty = 0;
let lastDifficultyBumpScore = 0;
let lastSpawnLaneIndex = -1;

// enemy skins
const ENEMY_KEYS = ["enemy_black", "enemy_blue", "enemy_orange", "enemy_green"];

// ✅ Smooth tilt steering variables
let tiltGamma = 0;                 // live tilt input (- left, + right)
let neutralDeadzone = 4;           // degrees where we treat as "center"
let steerMaxSpeed = 340;           // max px/sec lateral movement
let steerSensitivity = 1.0;        // multiply tilt strength
let steerSmooth = 0.12;            // 0..1 smoothing (higher = snappier)
let steerGammaSmoothed = 0;        // filtered gamma

// Lane boundaries (keep car on road)
let minX = 70;
let maxX = 280;

let overlayUI = {};

function preload() {
  // player + road
  this.load.image("car", "assets/car.png");
  this.load.image("road", "assets/road.png");

  // enemies
  this.load.image("enemy_black", "assets/blackcar.png");
  this.load.image("enemy_blue", "assets/bluecar.png");
  this.load.image("enemy_orange", "assets/orangecar.png");
  this.load.image("enemy_green", "assets/greencar.png");
}

function create() {
  // lanes (your tuned values)
  lanes = [70, 180, 280];
  minX = lanes[0];
  maxX = lanes[2];

  // road fill (two images loop)
  road1 = this.add.image(W/2, H/2, "road");
  roadScale = Math.max(W / road1.width, H / road1.height);
  road1.setScale(roadScale);

  road2 = this.add.image(W/2, H/2 - (road1.height * roadScale), "road");
  road2.setScale(roadScale);

  // player
  car = this.physics.add.sprite(lanes[1], H - 90, "car");
  car.setCollideWorldBounds(false); // we clamp manually to road bounds
  scaleSpriteToWidth(car, 47);

  enemies = this.physics.add.group();

  scoreText = this.add.text(10, 10, "Score: 0", {
    fontSize: "18px",
    fill: "#ffffff"
  });

  this.physics.add.overlap(car, enemies, () => onGameOver.call(this), null, this);

  setupTiltControls();
  showStartOverlay.call(this);

  // keyboard backup (smooth)
  this.input.keyboard.on("keydown-LEFT", () => { tiltGamma = -18; });
  this.input.keyboard.on("keydown-RIGHT", () => { tiltGamma = 18; });
  this.input.keyboard.on("keyup-LEFT", () => { tiltGamma = 0; });
  this.input.keyboard.on("keyup-RIGHT", () => { tiltGamma = 0; });
}

function update(time, delta) {
  const dt = delta / 1000;

  if (playing && !gameOver) {
    scrollRoad();
    maybeIncreaseDifficulty();
    spawnLogic(time);
    smoothSteer(dt);
  }

  if (!playing || gameOver) return;

  enemies.children.iterate((e) => {
    if (e && e.y > H + 140) {
      e.destroy();
      score++;
      scoreText.setText("Score: " + score);
    }
  });
}

// -------------------- SMOOTH STEERING --------------------

function smoothSteer(dt) {
  // Smooth the tilt value (filters jitter)
  steerGammaSmoothed = lerp(steerGammaSmoothed, tiltGamma, steerSmooth);

  // Deadzone near center so it doesn't drift
  let g = steerGammaSmoothed;
  if (Math.abs(g) < neutralDeadzone) g = 0;

  // Convert degrees into -1..1 steering
  // clamp at +/-25 degrees
  const norm = Phaser.Math.Clamp(g / 25, -1, 1) * steerSensitivity;

  // target velocity in px/sec
  const vx = norm * steerMaxSpeed;

  // Apply smooth motion
  car.x += vx * dt;

  // Auto-centering: if phone is level, gently pull toward center lane
  if (g === 0) {
    car.x = lerp(car.x, lanes[1], 0.06);
  }

  // Clamp to road boundaries
  car.x = Phaser.Math.Clamp(car.x, minX, maxX);
}

// -------------------- ROAD LOOP --------------------

function scrollRoad() {
  road1.y += roadScrollSpeed;
  road2.y += roadScrollSpeed;

  const roadHeight = road1.height * roadScale;

  if (road1.y - H/2 >= roadHeight) road1.y = road2.y - roadHeight;
  if (road2.y - H/2 >= roadHeight) road2.y = road1.y - roadHeight;
}

// -------------------- DIFFICULTY (aggressive) --------------------

function maybeIncreaseDifficulty() {
  if (score - lastDifficultyBumpScore >= 6) {
    lastDifficultyBumpScore = score;
    difficulty++;

    roadScrollSpeed += 0.35;
    enemySpeed += 18;

    // also slightly increase steering max speed so it still feels responsive later
    steerMaxSpeed = Math.min(520, steerMaxSpeed + 12);
  }
}

// -------------------- SPAWNING --------------------

function spawnLogic(timeMs) {
  if (timeMs < nextSpawnAt) return;

  const baseDelay = Math.max(900 - difficulty * 95, 260);
  const jitter = Phaser.Math.Between(-180, 220);

  const gapChance = Math.min(0.08 + difficulty * 0.015, 0.20);
  const gapExtra = (Math.random() < gapChance) ? Phaser.Math.Between(80, 200) : 0;

  const delay = Math.max(220, baseDelay + jitter + gapExtra);
  nextSpawnAt = timeMs + delay;

  const laneA = pickLaneIndexAvoidRepeat();
  spawnEnemyInLane(laneA);

  const allowDouble = difficulty >= 1;
  if (allowDouble) {
    const doubleChance = Math.min(0.12 + difficulty * 0.05, 0.50);
    if (Math.random() < doubleChance) {
      const laneB = pickDifferentLaneIndex(laneA);
      const extraDelay = Phaser.Math.Between(120, 260);
      setTimeout(() => {
        if (playing && !gameOver) spawnEnemyInLane(laneB);
      }, extraDelay);
    }
  }
}

function pickLaneIndexAvoidRepeat() {
  let choices = [0, 1, 2];
  if (lastSpawnLaneIndex !== -1 && Math.random() < 0.75) {
    choices = choices.filter(i => i !== lastSpawnLaneIndex);
  }
  const picked = Phaser.Utils.Array.GetRandom(choices);
  lastSpawnLaneIndex = picked;
  return picked;
}

function pickDifferentLaneIndex(notThisIndex) {
  let options = [0, 1, 2].filter(i => i !== notThisIndex);
  if (lastSpawnLaneIndex !== -1 && Math.random() < 0.6) {
    const options2 = options.filter(i => i !== lastSpawnLaneIndex);
    if (options2.length > 0) options = options2;
  }
  const picked = Phaser.Utils.Array.GetRandom(options);
  lastSpawnLaneIndex = picked;
  return picked;
}

function spawnEnemyInLane(laneIndex) {
  if (!playing || gameOver) return;

  const enemyKey = Phaser.Utils.Array.GetRandom(ENEMY_KEYS);
  const laneX = lanes[laneIndex];

  const e = enemies.create(laneX, -120, enemyKey);
  scaleSpriteToWidth(e, 47);
  e.setVelocityY(enemySpeed);

  // tiny variation
  e.x += Phaser.Math.Between(-2, 2);
}

// -------------------- GAME FLOW --------------------

function startGame() {
  score = 0;
  scoreText.setText("Score: 0");
  gameOver = false;
  playing = true;

  difficulty = 0;
  lastDifficultyBumpScore = 0;
  lastSpawnLaneIndex = -1;

  enemySpeed = 220;
  roadScrollSpeed = 2.2;

  enemies.clear(true, true);
  hideOverlay();

  nextSpawnAt = performance.now() + 850;
}

function onGameOver() {
  if (gameOver) return;

  gameOver = true;
  playing = false;
  roadScrollSpeed = 0;

  this.physics.pause();
  showGameOverOverlay.call(this);
}

// -------------------- UI --------------------

function showStartOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.45);

  overlayUI.title = this.add.text(W/2, H/2 - 90, "ROAD RACER", {
    fontSize: "32px",
    fill: "#ffffff"
  }).setOrigin(0.5);

  overlayUI.tip = this.add.text(W/2, H/2 - 40, "Tap START • Tilt to steer smoothly", {
    fontSize: "14px",
    fill: "#dddddd"
  }).setOrigin(0.5);

  overlayUI.btn = makeButton(this, W/2, H/2 + 40, "START", () => {
    this.physics.resume();
    startGame.call(this);
  });
}

function showGameOverOverlay() {
  overlayUI.bg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.45);

  overlayUI.title = this.add.text(W/2, H/2 - 90, "GAME OVER", {
    fontSize: "32px",
    fill: "#ff4444"
  }).setOrigin(0.5);

  overlayUI.tip = this.add.text(W/2, H/2 - 40, `Final Score: ${score}`, {
    fontSize: "16px",
    fill: "#ffffff"
  }).setOrigin(0.5);

  overlayUI.btn = makeButton(this, W/2, H/2 + 40, "RESTART", () => {
    this.physics.resume();
    startGame.call(this);
  });
}

function hideOverlay() {
  Object.values(overlayUI).forEach(o => o && o.destroy && o.destroy());
  overlayUI = {};
}

function makeButton(scene, x, y, label, onClick) {
  const btnBg = scene.add.rectangle(x, y, 170, 54, 0x22c55e, 1)
    .setStrokeStyle(2, 0xffffff, 1);

  const btnText = scene.add.text(x, y, label, {
    fontSize: "20px",
    fill: "#ffffff"
  }).setOrigin(0.5);

  btnBg.setInteractive({ useHandCursor: true });
  btnBg.on("pointerdown", onClick);

  return { destroy: () => { btnBg.destroy(); btnText.destroy(); } };
}

// -------------------- TILT --------------------

function setupTiltControls() {
  const requestIOSPermissionIfNeeded = async () => {
    try {
      if (
        typeof DeviceOrientationEvent !== "undefined" &&
        typeof DeviceOrientationEvent.requestPermission === "function"
      ) {
        const result = await DeviceOrientationEvent.requestPermission();
        console.log("iOS tilt permission:", result);
      }
    } catch (e) {
      console.log("Tilt permission error:", e);
    }
  };

  window.addEventListener("click", () => requestIOSPermissionIfNeeded(), { once: true });

  window.addEventListener("deviceorientation", (event) => {
    if (!playing || gameOver) return;
    tiltGamma = event.gamma ?? 0; // store tilt, we smooth it in update()
  });
}

// -------------------- HELPERS --------------------

function scaleSpriteToWidth(sprite, targetWidthPx) {
  const texW = sprite.width || 1;
  sprite.setScale(targetWidthPx / texW);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}
</script>

</body>
</html>
